# -*- coding: utf-8 -*-
"""dataMiningLab3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fZ1m-1JkV7hYnC3Mji4CVEEl0jkIV5Cq

# Importing and Initializing
"""

# import libraries
import csv
import pandas as pd
# Anytree is only used to visualize and maintain tree data structure
from anytree import Node, RenderTree
import itertools

"""Utility Functions"""


def get_data_set_from_csv(path):
    with open(path) as csv_file:
        data_set = csv.reader(csv_file, delimiter=',')
        transaction_items = [x for x in data_set]
        return transaction_items

# get list of unique items present in a list of transactions


def get_unique_items(transaction_items):
    unique_items = set()
    for items in transaction_items:
        for item in items:
            unique_items.add(item)
    return list(unique_items)

# Convert a list of list transactions to a list of dict/hashmap transaction


def get_dict_list_from_transaction_items(transaction_items, unique_items):
    transaction_dict_list = []
    for items in transaction_items:
        item_dict = {x: 0 for x in unique_items}
        for item in items:
            item_dict[item] += 1
        transaction_dict_list.append(item_dict)
    return transaction_dict_list


def build_tree(root, item_set, node_list=[]):
    if(len(item_set) == 0):
        return
    children = root.children
    item = item_set[0]
    for child in children:
        name, count = tuple(child.name.split(':'))
        if name == item:
            child.name = name + ':' + str(int(count)+1)
            build_tree(child, item_set[1:], node_list)
            return
    new_child = Node(str(item)+':1', parent=root)
    if(len(node_list) != 0):
        node_list[item][1].append(new_child)
    build_tree(new_child, item_set[1:], node_list)


def filter_tree(root, min_support):
    children = root.children
    new_children = []
    for child in children:
        name, count = tuple(child.name.split(':'))
        if int(count) >= min_support:
            filter_tree(child, min_support)
            new_children.append(child)
    root.children = new_children


def get_trees(root):
    if root.is_leaf:
        return [{x.name.split(':')[0]:int(x.name.split(':')[1]) for x in root.path[1:]}]
    children = root.children
    tree_list = []
    for child in children:
        tree_list.extend(get_trees(child))
    return tree_list


def get_string(root):
    tree_string = ""
    for pre, fill, node in RenderTree(root):
        tree_string += pre+node.name+'\n'
    return tree_string

# find all the subsets of size n of a set


def findsubsets(s, n):
    return list(itertools.combinations(s, n))


# loading the data set
transaction_items = get_data_set_from_csv('input.csv')

# calculating all the unique items
unique_items = get_unique_items(transaction_items)
min_support = int(input("Enter the minimum support COUNT: "))

pattern_set = {item: 0 for item in unique_items}
for row in transaction_items:
    for uq in row:
        pattern_set[uq] += 1
freq_pattern_set = {k: v for k, v in pattern_set.items() if v >= min_support}

freq_pattern_set_items = sorted(freq_pattern_set.items(), key=lambda x: x[0])
freq_pattern_set_items = sorted(freq_pattern_set_items, key=lambda x: x[1],
                                reverse=True)
freq_pattern_set_keys = [str(x[0]) for x in freq_pattern_set_items]
print('\nOrdered Itemset', freq_pattern_set_keys)

# FP Tree Creation
root = Node("{}")
node_list = {item: (freq_pattern_set[item], [])
             for item in freq_pattern_set_keys}
print('\nOrdered Items for each transaction')
for row in transaction_items:
    ordered_item_set = []
    for uq in freq_pattern_set_keys:
        if uq in list(row):
            ordered_item_set.append(uq)
    print(ordered_item_set)
    build_tree(root, ordered_item_set, node_list)
print("\nThe FP Tree:")
print(get_string(root))


# Conditional pattern generation
final_table = {item: {
    "Cond Pattern": {}
} for item in freq_pattern_set_keys}

for item in freq_pattern_set_keys:
    for nod in node_list[item][1]:
        path_items = []
        for nd in nod.path[1:-1]:
            path_items.append(nd.name.split(":")[0])
        if len(path_items) > 0:
            final_table[item]["Cond Pattern"][
                tuple(path_items)] = int(nod.path[-1].name.split(':')[1])
fdf = pd.DataFrame(final_table).T[['Cond Pattern']]
print(fdf.to_string())

# Conditional FP Tree Generation
for item in freq_pattern_set_keys:
    cond_root = Node('{}')
    fq_items = {itm: 0 for itm in freq_pattern_set_keys}

    for pattern, cout in final_table[item]["Cond Pattern"].items():
        for itm in pattern:
            fq_items[itm] += cout

    fq_items_set = sorted(fq_items.items(), key=lambda x: x[1],
                          reverse=True)
    fq_items_set_keys = [str(x[0])
                         for x in fq_items_set if x[1] >= min_support]
    cnt = 0
    for pattern, count in final_table[item]["Cond Pattern"].items():
        ordered_pattern = []
        for uq in fq_items_set_keys:
            if uq in pattern:
                ordered_pattern.append(uq)
        while count > 0:
            build_tree(cond_root, ordered_pattern)
            count -= 1
    final_table[item]["Cond root"] = get_string(cond_root)
    final_table[item]["Cond fp tree"] = get_trees(cond_root)

# Frequent Pattern Generation
freq_pattern_table = {}
for item in freq_pattern_set_keys:
    freq_pat = set()
    for path in final_table[item]["Cond fp tree"]:
        item_set = set(path.keys())
        for i in range(1, len(item_set)+1):
            subsets = findsubsets(item_set, i)
            for subset in subsets:
                subset = set(subset)
                min_cnt = float('inf')
                for st in subset:
                    min_cnt = min(path[st], min_cnt)
                subset.add(item)
                freq_pat.add(tuple(subset))
    if not len(freq_pat) == 0:
        if item not in freq_pattern_table:
            freq_pattern_table[item] = {}
        freq_pattern_table[item]["Freq Pattern"] = freq_pat

fdf = pd.DataFrame(freq_pattern_table).T[['Freq Pattern']]
print('--------------------------------------------------------\n\nFor absolute min support of', min_support,
      'items, following are the frequent pattern\n\n')
print('Item')
print(fdf.to_string())
print('\nConditional Trees\n')
for k in freq_pattern_set_keys:
    print(k)
    print(final_table[k]['Cond root'])
print('\n\n--------------------------------------------------------')
